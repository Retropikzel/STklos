;;;;
;;;; events.stk                                  -- GTK Events Management
;;;;
;;;; Copyright © 2001-2021 Erick Gallesio - I3S-CNRS/ESSI <eg@unice.fr>
;;;;
;;;;
;;;; This program is free software; you can redistribute it and/or modify
;;;; it under the terms of the GNU General Public License as published by
;;;; the Free Software Foundation; either version 2 of the License, or
;;;; (at your option) any later version.
;;;;
;;;; This program is distributed in the hope that it will be useful,
;;;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;;;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;;;; GNU General Public License for more details.
;;;;
;;;; You should have received a copy of the GNU General Public License
;;;; along with this program; if not, write to the Free Software
;;;; Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
;;;; USA.
;;;;
;;;;           Author: Erick Gallesio [eg@unice.fr]
;;;;    Creation date: 31-May-2001 18:36 (eg)
;;;; Last file update: 16-Jun-2021 19:56 (eg)
;;;;

;;;
;;; GTK bindings
;;;
(define-external g-signal-connect-data ((widget #:pointer)  (name #:string)
                                        (proc #:pointer)    (data #:obj)
                                        (unused1 #:pointer) (unused2 :int))
  :entry-name "g_signal_connect_data"
  :library-name (find-gtk-library 'gobject))


;;; ______________________________________________________________________
;;;
;;; Low level signal management
;;;
;;; ----------------------------------------------------------------------
(define (%do-signal-connect widget name proc data after)
  (let ((cb (make-callback proc
                           '(#:pointer)
                           data)))
    ;; This call correspond to the C call
    ;;     g_signal_connect_swapped(widget, name, callback, cb);
    ;; The value 2 below correspond to swapped callbacks where the user data
    ;; is the first argument of the callback
    (g-signal-connect-data widget
                           name
                           (%exec-callback-address)
                           cb
                           (void)
                           (+ 2 (if after 1 0)))))


(define (g-signal-connect widget name proc data)
  (let ((closure (lambda (w widget) (proc widget))))
    (%do-signal-connect widget name closure widget #f)))

(define (g-signal-connect-after widget name proc data)
  (let ((closure (lambda (w widget) (proc widget))))
    (%do-signal-connect widget name closure widget #t)))


(define (scheme-proc->gtk-handler proc scheme-widget)
  ;; GTK handlers can have a variable number of parameters depending of the signal
  ;; For instance
  ;;     - a clicked button handler will be called with the gtk-widget and
  ;;       the user given data 
  ;;     - a keypress handler will be called with the gtk-widget the keypress and
  ;;       and the user given data
  ;; To simplify Scheme code, all handlers take 2 parameters, the scheme widget object
  ;; and an event object.
  (lambda _    ;; We don't care of the parameters here.
    ;; call the user handler with 2 parameters
    (proc scheme-widget (get-gtk-event))))

; ======================================================================




;;//FIXME:
;;//FIXME:
;;//FIXME:
;;//FIXME:
;;//FIXME:(define (%event-getter-func name)
;;//FIXME:  (let ((key (make-keyword name)))
;;//FIXME:    (lambda (o)
;;//FIXME:      (key-get (slot-ref o '%event) key #f))))
;;//FIXME:
;;//FIXME:
;;//FIXME:(define (%event-setter-func name)
;;//FIXME:  (let ((key (make-keyword name)))
;;//FIXME:    (lambda (o v)
;;//FIXME:      (let ((new (lambda _ (v (new-gtk-event)))))
;;//FIXME:        (slot-set! o '%event (key-set! (slot-ref o '%event) key new))
;;//FIXME:        (g-signal-connect (slot-ref o 'wid) name new (void))))))
;;//FIXME:
;;//FIXME:
;;//FIXME:(define (%signal-connect widget wid name closure after)
;;//FIXME:  (let ((key     (make-keyword name))
;;//FIXME:        (new     (lambda _ (closure (new-gtk-event))))
;;//FIXME:        (connect (if after g-signal-connect-after g-signal-connect)))
;;//FIXME:    (slot-set! widget '%event (key-set! (slot-ref widget '%event) key new))
;;//FIXME:    (connect wid name new (void))))
;;//FIXME:
;;//FIXME:; ======================================================================
;;//FIXME:
;;//FIXME:(define-struct gtk-event obj)
;;//FIXME:
;;//FIXME:(define (new-gtk-event)
;;//FIXME:  (let ((ev (gtk-get-current-event)))
;;//FIXME:    (if (eq? ev #void)
;;//FIXME:        #f
;;//FIXME:        (make-gtk-event ev))))
;;//FIXME:
;;//FIXME:(define (event-widget e)
;;//FIXME:  (if (gtk-event? e)
;;//FIXME:      (diw (gtk-get-event-widget (gtk-event-obj e)))
;;//FIXME:      (error "bad event ~S" e)))
;;//FIXME:
;;//FIXME:(define (event-type e)
;;//FIXME:  (if (gtk-event? e)
;;//FIXME:      (%event-type (gtk-event-obj e))
;;//FIXME:      (error "bad event ~S" e)))
;;//FIXME:
;;//FIXME:(define (event-x e)
;;//FIXME:  (if (gtk-event? e)
;;//FIXME:      (%event-x (gtk-event-obj e))
;;//FIXME:      (error "bad event ~S" e)))
;;//FIXME:
;;//FIXME:(define (event-y e)
;;//FIXME:  (if (gtk-event? e)
;;//FIXME:      (%event-y (gtk-event-obj e))
;;//FIXME:      (error "bad event ~S" e)))
;;//FIXME:
;;//FIXME:
;;//FIXME:(define (event-button e)
;;//FIXME:  (if (gtk-event? e)
;;//FIXME:      (%event-button (gtk-event-obj e))
;;//FIXME:      (error "bad event ~S" e)))
;;//FIXME:
;;//FIXME:
;;//FIXME:(define (event-describe e)
;;//FIXME:  (eprintf "event description ~S\n" e)
;;//FIXME:  (eprintf "\t   widget: ~S\n" (event-widget e))
;;//FIXME:  (eprintf "\t     type: ~S\n" (event-type e))
;;//FIXME:  (eprintf "\t   button: ~S\n" (event-button e))
;;//FIXME:  (eprintf "\tmodifiers: ~S\n" (event-modifiers e))
;;//FIXME:  (eprintf "\t     char: ~S\n" (event-char e))
;;//FIXME:  (eprintf "\t        x: ~S\n" (event-x e))
;;//FIXME:  (eprintf "\t        y: ~S\n" (event-y e)))


;;;
;;; Exports
;;;
(export g-signal-connect g-signal-connect-after
        event-char event-modifiers)
