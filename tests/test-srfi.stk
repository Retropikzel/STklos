;;;;
;;;; test-srfi.stk  -- Test of various SRFIs
;;;;
;;;; Copyright © 2005-2020 Erick Gallesio - I3S-CNRS/ESSI <eg@essi.fr>
;;;;
;;;;
;;;; This program is free software; you can redistribute it and/or modify
;;;; it under the terms of the GNU General Public License as published by
;;;; the Free Software Foundation; either version 2 of the License, or
;;;; (at your option) any later version.
;;;;
;;;; This program is distributed in the hope that it will be useful,
;;;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;;;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;;;; GNU General Public License for more details.
;;;;
;;;; You should have received a copy of the GNU General Public License
;;;; along with this program; if not, write to the Free Software
;;;; Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
;;;; USA.
;;;;
;;;;           Author: Erick Gallesio [eg@essi.fr]
;;;;    Creation date:  4-Aug-2005 10:34 (eg)
;;;; Last file update: 23-Nov-2020 10:19 (eg)
;;;;

(require "test")

(test-section "SRFIs")


;;;
;;; Run all the tests in "./srfi" directory
;;
(include "../lib/srfis.stk")

(dotimes (nb (last-implemented-srfi))
  (let ((desc (find-srfi nb)))
    (when desc                            ;; We have an impl. for this SRFI
      (let ((test-file (format "./srfi/~a.stk" nb)))
        (when (file-exists? test-file)    ;; and we have a test for it
          ;; Add a subsection title
          (test-subsection (format "SRFI ~S - ~S ..." nb (srfi-title desc)))
          ;; Eventually require the SRFI
          (let* ((name    (symbol-append 'srfi- nb))
                 (to-load (srfi-0-feature-implementation-file name)))
            (when to-load
              (for-each (lambda (x)
                          ;; /!\ do not use the function but the require macro!!
                          (require x)) 
                        to-load)))
          ;; Run the tests
          (load test-file))))))






;; ----------------------------------------------------------------------
;;  SRFI 175 ...
;; ----------------------------------------------------------------------
(test-subsection "SRFI 175 - ASCII character library")

(require "srfi-175")


(test "ascii 1" #f (ascii-codepoint? -1))
(test "ascii 2" #t (ascii-codepoint? 0))
(test "ascii 3" #t (ascii-codepoint? #x7f))
(test "ascii 4" #f (ascii-codepoint? #x80))

(test "ascii 5" #t (ascii-char? (integer->char 0)))
(test "ascii 6" #t (ascii-char? (integer->char #x7f)))
(test "ascii 7" #f (ascii-char? (integer->char #x80)))

(test "ascii 8" #t (ascii-string? ""))
(test "ascii 9" #t (ascii-string? "a"))
(test "ascii 10" #t (ascii-string? "a b c"))
(test "ascii 11" #f (ascii-string? "å b o"))
(test "ascii 12" #t (ascii-string? (make-string 1 (integer->char #x7f))))
(test "ascii 13" #f (ascii-string? (make-string 1 (integer->char #x80))))

(test "ascii 14" #t (ascii-bytevector? (string->utf8 "")))
(test "ascii 15" #t (ascii-bytevector? (string->utf8 "a")))
(test "ascii 16" #t (ascii-bytevector? (string->utf8 "a b c")))
(test "ascii 17" #f (ascii-bytevector? (string->utf8 "å b o")))
(test "ascii 18" #t (ascii-bytevector?
          (string->utf8 (make-string 1 (integer->char #x7f)))))
(test "ascii 19" #f (ascii-bytevector?
          (string->utf8 (make-string 1 (integer->char #x80)))))

(test "ascii 20" #t (ascii-non-control? #\space))
(test "ascii 21" #f (ascii-non-control? #\tab))
(test "ascii 22" #f (ascii-non-control? #\newline))
(test "ascii 23" #f (ascii-non-control? (integer->char #x0d)))

(test "ascii 24" #t (ascii-space-or-tab? #\space))
(test "ascii 25" #t (ascii-space-or-tab? #\tab))
(test "ascii 26" #f (ascii-space-or-tab? #\newline))
(test "ascii 27" #f (ascii-non-control? (integer->char #x0d)))

(test "ascii 28" #f (ascii-non-control? (integer->char #x00)))
(test "ascii 29" #f (ascii-non-control? (integer->char #x1f)))
(test "ascii 30" #t (ascii-non-control? (integer->char #x20)))
(test "ascii 31" #t (ascii-non-control? (integer->char #x7e)))
(test "ascii 32" #f (ascii-non-control? (integer->char #x7f)))
(test "ascii 33" #f (ascii-non-control? (integer->char #x80)))

(let ((lowers "abcdefghijklmnopqrstuvwxyz")
      (uppers "ABCDEFGHIJKLMNOPQRSTUVWXYZ"))
  (let loop ((i 0))
    (when (< i 26)
      (let ((lower (string-ref lowers i))
            (upper (string-ref uppers i)))
        (test "ascii 34" upper (ascii-upcase upper))
        (test "ascii 35" upper (ascii-upcase lower))
        (test "ascii 36" lower (ascii-downcase upper))
        (test "ascii 37" lower (ascii-downcase lower))
        (loop (+ i 1))))))

(let loop ((cc 0))
  (when (< cc #x80)
    (unless (ascii-alphabetic? cc)
      (test "ascii 38" cc (ascii-upcase cc))
      (test "ascii 39" cc (ascii-downcase cc)))
    (loop (+ cc 1))))

(let loop ((cc 0))
  (when (< cc #x80)
    (test "ascii 40" #f (ascii-char? cc))
    (test "ascii 41" #t (ascii-char? (integer->char cc)))
    (cond ((ascii-alphabetic? cc)
           (test "ascii 42" #t (ascii-upper-case? (ascii-upcase cc)))
           (test "ascii 43" #t (ascii-lower-case? (ascii-downcase cc)))
           (test "ascii 44" #f (ascii-lower-case? (ascii-upcase cc)))
           (test "ascii 45" #f (ascii-upper-case? (ascii-downcase cc)))
           (test "ascii 46" #t (ascii-alphanumeric? cc))
           (test "ascii 47" #t (ascii-non-control? cc))
           (test "ascii 48" #f (ascii-other-graphic? cc))
           (test "ascii 49" #f (ascii-control? cc))
           (test "ascii 50" #f (ascii-numeric? cc))
           (test "ascii 51" #f (ascii-whitespace? cc))
           (test "ascii 52" #f (ascii-space-or-tab? cc)))
          ((ascii-control? cc)
           (test "ascii 53" #f (ascii-non-control? cc))
           (test "ascii 54" #f (ascii-other-graphic? cc))
           (test "ascii 55" cc
                 (ascii-graphic->control
                  (ascii-control->graphic cc)))
           (test "ascii 56" (integer->char cc)
                 (ascii-graphic->control
                  (ascii-control->graphic (integer->char cc)))))
          ((member cc '(#\( #\) #\[ #\] #\{ #\} #\< #\>))
           (test "ascii 57" cc (ascii-mirror-bracket (ascii-mirror-bracket cc)))))
    (loop (+ cc 1))))

(let outer ((a 0))
  (when (< a 26)
    (let inner ((b 0))
      (if (= b 26)
          (outer (+ a 1))
          (begin (test "ascii 58" (= a b)  (ascii-ci=?
                                 (ascii-nth-lower-case a)
                                 (ascii-nth-upper-case b)))
                 (test "ascii 59" (< a b)  (ascii-ci<?
                                 (ascii-nth-lower-case a)
                                 (ascii-nth-upper-case b)))
                 (test "ascii 60" (<= a b) (ascii-ci<=?
                                 (ascii-nth-lower-case a)
                                 (ascii-nth-upper-case b)))
                 (test "ascii 61" (> a b)  (ascii-ci>?
                                 (ascii-nth-lower-case a)
                                 (ascii-nth-upper-case b)))
                 (test "ascii 62" (>= a b) (ascii-ci>=?
                                 (ascii-nth-lower-case a)
                                 (ascii-nth-upper-case b)))
                 (inner (+ b 1)))))))

(ascii-ci>? #\A #\_)
(ascii-ci>? #\Z #\_)

(test "ascii 63" #f (ascii-char? -1))
(test "ascii 64" #f (ascii-char? #x80))
(test "ascii 65" #f (ascii-char? (integer->char #x80)))

(test "ascii 66" #f (ascii-control? -1))
(test "ascii 67" #t (ascii-control? #x00))
(test "ascii 68" #t (ascii-control? #x1f))
(test "ascii 69" #f (ascii-control? #x20))
(test "ascii 70" #f (ascii-control? #x7e))
(test "ascii 71" #t (ascii-control? #x7f))
(test "ascii 72" #f (ascii-control? #x80))

(test "ascii 73" 0 (ascii-digit-value #\0 10))
(test "ascii 74" 0 (ascii-digit-value #\0 1))
(test "ascii 75" #f (ascii-digit-value #\0 0))
(test "ascii 76" #f (ascii-digit-value #\0 -1))
(test "ascii 77" 7 (ascii-digit-value #\7 8))
(test "ascii 78" #f (ascii-digit-value #\7 7))
(test "ascii 79" #f (ascii-digit-value #\: 10))

(test "ascii 80" 0 (ascii-upper-case-value #\A 0 26))
(test "ascii 81" 25 (ascii-upper-case-value #\Z 0 26))
(test "ascii 82" #f (ascii-upper-case-value #\Z 0 25))

(test "ascii 83" 0 (ascii-lower-case-value #\a 0 26))
(test "ascii 84" 25 (ascii-lower-case-value #\z 0 26))
(test "ascii 85" #f (ascii-lower-case-value #\z 0 25))

(test "ascii 86" 0 (ascii-lower-case-value #\a 0 1))
(test "ascii 87" #f (ascii-lower-case-value #\a 0 0))
(test "ascii 88" #f (ascii-lower-case-value #\a 0 -1))
(test "ascii 89" 9001 (ascii-lower-case-value #\b 9000 2))

(test "ascii 90" #f (ascii-nth-digit -1))
(test "ascii 91" #\0 (ascii-nth-digit 0))
(test "ascii 92" #\9 (ascii-nth-digit 9))
(test "ascii 93" #f (ascii-nth-digit 10))

(test "ascii 94" #\Z (ascii-nth-upper-case -1))
(test "ascii 95" #\A (ascii-nth-upper-case 0))
(test "ascii 96" #\Z (ascii-nth-upper-case 25))
(test "ascii 97" #\A (ascii-nth-upper-case 26))

(test "ascii 98" #\z (ascii-nth-lower-case -1))
(test "ascii 99" #\a (ascii-nth-lower-case 0))
(test "ascii 100" #\z (ascii-nth-lower-case 25))
(test "ascii 101" #\a (ascii-nth-lower-case 26))

(define (count-matching predicates value)
  (let loop ((ps predicates) (n 0))
    (if (null? ps) n (loop (cdr ps) (if ((car ps) value) (+ n 1) n)))))

(define (union? whole . parts)
  (let check ((cc 0))
    (or (= cc #x80)
        (if (and (whole cc) (not (= 1 (count-matching parts cc))))
            #f (check (+ cc 1))))))

(define (subset? small-set . bigger-sets)
  (let check ((cc 0))
    (or (= cc #x80)
        (if (and (small-set cc) (= 0 (count-matching bigger-sets cc)))
            #f (check (+ cc 1))))))

(define (disjoint? . predicates)
  (let check ((cc 0))
    (or (= cc #x80) (and (<= (count-matching predicates cc) 1)
                         (check (+ cc 1))))))

(test "ascii 102" #t (union? ascii-alphanumeric? ascii-alphabetic? ascii-numeric?))
(test "ascii 103" #t (union? ascii-alphabetic? ascii-upper-case? ascii-lower-case?))

(test "ascii 104" #t (subset? ascii-space-or-tab? ascii-whitespace?))
(test "ascii 105" #t (subset? ascii-other-graphic? ascii-non-control?))
(test "ascii 106" #t (subset? ascii-upper-case?   ascii-alphabetic? ascii-non-control?))
(test "ascii 107" #t (subset? ascii-lower-case?   ascii-alphabetic? ascii-non-control?))
(test "ascii 108" #t (subset? ascii-alphabetic?   ascii-alphanumeric? ascii-non-control?))
(test "ascii 109" #t (subset? ascii-numeric?      ascii-alphanumeric? ascii-non-control?))
(test "ascii 110" #t (subset? ascii-alphanumeric? ascii-non-control?))

(test "ascii 111" #t (disjoint? ascii-control? ascii-non-control?))
(test "ascii 112" #t (disjoint? ascii-whitespace?
                    ascii-other-graphic?
                    ascii-upper-case?
                    ascii-lower-case?
                    ascii-numeric?))
(test "ascii 113" #t (disjoint? ascii-control?
                    ascii-other-graphic?
                    ascii-upper-case?
                    ascii-lower-case?
                    ascii-numeric?))

(define (check-string-ci a b cmp)
  (test "ascii 114" (= cmp 0) (ascii-string-ci=? a b))
  (test "ascii 115" (< cmp 0) (ascii-string-ci<? a b))
  (test "ascii 116" (> cmp 0) (ascii-string-ci>? a b))
  (test "ascii 117" (<= cmp 0) (ascii-string-ci<=? a b))
  (test "ascii 118" (>= cmp 0) (ascii-string-ci>=? a b)))

(check-string-ci "" "" 0)
(check-string-ci "a" "a" 0)
(check-string-ci "A" "a" 0)
(check-string-ci "a" "A" 0)

(check-string-ci "a" "b" -1)
(check-string-ci "b" "a" 1)

(check-string-ci "a" "B" -1)
(check-string-ci "B" "a" 1)

(check-string-ci "aa" "aa" 0)
(check-string-ci "aa" "ab" -1)
(check-string-ci "ab" "aa" 1)
(check-string-ci "aa" "aaa" -1)
(check-string-ci "aaa" "aa" 1)


;; ----------------------------------------------------------------------
;;  SRFI 185 ...
;; ----------------------------------------------------------------------

(require "srfi-185")


(test "string-append! ok"  #t (eq? string-append! string-append-linear!))
(test "string-replace! ok" #t (eq? string-replace! string-replace-linear!))

;; srting-append! and string-replace! should now be macros, and they should
;; NOT expand to themselves!
(test "string-append! expansion"
      #f
      (equal? '(string-append! a b c)
              (macro-expand '(string-append! a b c))))

(test "string-replace! expansion"
      #f
      (equal? '(string-replace! dst dst-start dst-end src src-start src-end)
              (macro-expand '(string-replace! dst dst-start dst-end src src-start src-end))))

;; repeat part of SRFI-118 tests here, although nothing should go wrong --
;; the procedures being used here were already tested!
(set-mutable-string! au6  "ábcdÊf")
(test "(linear) string-append! char, unicode" "ábcdÊfঈ2345༫"
      (begin (string-append! au6 #\ঈ #\2 "345" #\༫) au6))
(set-mutable-string! au6  "ábcdÊf")
(test "(linear) string-append! char, unicode, length" 12
      (begin (string-append! au6 #\ঈ #\2 "345" #\༫) (string-length au6)))
;; FIXME: Delete this test
;; (set-mutable-string! au6  "ábcdÊf")
;; (test "(linear) string-append! char, unidoce, eq?" #t (eq? au6 (string-append! au6 #\ঈ #\2 "345" #\༫)))

(set-mutable-string! a6 "abcdef")
(test "(linear) string-replace! overlap" "abefef" (begin (string-replace! a6 2 4 a6 4 6) a6))
(set-mutable-string! a6 "abcdef")
(test "(linear) string-replace! overlap length" 6  (begin (string-replace! a6 2 4 a6 4 6)
                                                          (string-length a6)))
;; FIXME: Delete this test
;; (set-mutable-string! a6 "abcdef")
;; (test "(linear) string-replace! overlap eq?" #t  (eq? a6 (string-replace! a6 2 4 a6 4 6)))



;; ----------------------------------------------------------------------
;;  SRFI 189 ...
;; ----------------------------------------------------------------------
(test-subsection "SRFI 189 - Maybe and Either: optional container types")

(require "srfi-189")

(define (identity x) x)


(define-syntax constantly
  (syntax-rules ()
    ((_ obj) (lambda _ obj))))

(define-syntax values->list
  (syntax-rules ()
    ((_ expr)
     (call-with-values (lambda () expr) list))))

(define always (constantly #t))
(define never (constantly #f))


;; Verify that a Maybe is a Just of 'z, a dummy object.
(define (just-of-z? m)
  (and (maybe? m) (maybe= eqv? m (just 'z))))

;; Verify that an Either is a Right of 'z, a dummy object.
(define (right-of-z? e)
  (and (either? e) (either= eqv? e (right 'z))))

;; Verify that an Either is a Left of 'z, a dummy object.
(define (left-of-z? e)
  (and (either? e) (either= eqv? e (left 'z))))

;; CONSTRUCTORS

;; Uniqueness of the Nothing object.
(test "eq? nothing" #t (eq? (nothing) (nothing)))

;; list->just and list->right
(test "list->just and list->right 1" #t (maybe= eqv? (just #t #t) (list->just '(#t #t))))
(test "list->just and list->right 2" #t (either= eqv? (right #t #t) (list->right '(#t #t))))
(test "list->just and list->right 3" #t (either= eqv? (left #t #t) (list->left '(#t #t))))

;; maybe->either and either->maybe
(test "maybe->either and either->maybe 1" #t (left-of-z? (maybe->either (nothing) 'z)))
(test "maybe->either and either->maybe 2" #t (right-of-z? (maybe->either (just 'z) #f)))
(test "maybe->either and either->maybe 3" #t (either= eqv? (right #t #t) (maybe->either (just #t #t) #f)))
(test "maybe->either and either->maybe 4" #t (nothing? (either->maybe (left #t))))
(test "maybe->either and either->maybe 5" #t (just-of-z? (either->maybe (right 'z))))
(test "maybe->either and either->maybe 6" #t (maybe= eqv? (just #t #t) (either->maybe (right #t #t))))

;; either-swap
(test "either-swap 1" #t (either= eqv? (right #t #t) (either-swap (left #t #t))))
(test "either-swap 2" #t (either= eqv? (left #t #t) (either-swap (right #t #t))))

;;;; Predicates

(test "predicates 1" #t (just? (just 'z)))
(test "predicates 2" #f (just? (nothing)))
(test "predicates 3" #f (nothing? (just 'z)))
(test "predicates 4" #t (nothing? (nothing)))
(test "predicates 5" #t (maybe? (just 'z)))
(test "predicates 6" #t (maybe? (nothing)))

(test "predicates 7" #t (right? (right 'z)))
(test "predicates 8" #f (right? (left 'z)))
(test "predicates 9" #f (left? (right 'z)))
(test "predicates 10" #t (left? (left 'z)))
(test "predicates 11" #t (either? (right 'z)))
(test "predicates 12" #t (either? (left 'z)))

(test "predicates 13" #t (maybe= eqv? (just #t) (just #t)))
(test "predicates 14" #f (maybe= eqv? (just #t) (just #f)))
(test "predicates 15" #t (maybe= eqv? (nothing) (nothing)))
(test "predicates 16" #f (maybe= eqv? (just #t) (nothing)))

(test "predicates 17" #t (maybe= eqv? (just #t #f) (just #t #f)))
(test "predicates 18" #f (maybe= eqv? (just #t #f) (just #t 'z)))
(test "predicates 19" #f (maybe= eqv? (just #t #f) (just #t)))

(test "predicates 20" #t (maybe= eqv? (just #t) (just #t) (just #t)))
(test "predicates 21" #t (maybe= eqv? (nothing) (nothing) (nothing)))
(test "predicates 22" #f (maybe= eqv? (just #t) (just #t) (nothing)))
(test "predicates 23" #f (maybe= eqv? (just #t) (just #t) (just #f)))
(test "predicates 24" #t (maybe= eqv? (just #t 'z) (just #t 'z) (just #t 'z)))

(test "predicates 25" #t (either= eqv? (right #t) (right #t)))
(test "predicates 26" #f (either= eqv? (right #t) (right #f)))
(test "predicates 27" #t (either= eqv? (left #t) (left #t)))
(test "predicates 28" #f (either= eqv? (left #t) (left #f)))
(test "predicates 29" #f (either= eqv? (right #t) (left #t)))

(test "predicates 30" #t (either= eqv? (right #t #f) (right #t #f)))
(test "predicates 31" #f (either= eqv? (right #t #f) (right #t 'z)))
(test "predicates 32" #f (either= eqv? (right #t #f) (right #t)))
(test "predicates 33" #t (either= eqv? (left #t #f) (left #t #f)))
(test "predicates 34" #f (either= eqv? (left #t #f) (left #t 'z)))
(test "predicates 35" #f (either= eqv? (left #t #f) (left #t)))
(test "predicates 36" #f (either= eqv? (left #t #f) (right #t #f)))

(test "predicates 37" #t (either= eqv? (right #t) (right #t) (right #t)))
(test "predicates 38" #t (either= eqv? (left #t) (left #t) (left #t)))
(test "predicates 39" #f (either= eqv? (right #t) (right #t) (left #t)))
(test "predicates 40" #f (either= eqv? (right #t) (right #t) (right #f)))
(test "predicates 41" #t (either= eqv? (right #t 'z) (right #t 'z) (right #t 'z)))

;;;; Accessors

(test "accessors 1" #f (maybe-ref (nothing) (lambda () #f)))
(test "accessors 2" #t (maybe-ref (just #t) (lambda () #f) values))
(test "accessors 3" #f (maybe-ref (nothing) (lambda () #f) values))

(test "accessors 4" '(#t #f) (values->list (maybe-ref (just #t #f) (lambda () #f))))
(test "accessors 5" '(#t #f) (maybe-ref (just #t #f) (lambda () #f) list))

(test "accessors 6" #f (either-ref (left #t) (constantly #f)))
(test "accessors 7" #t (either-ref (right #t) (constantly #f) values))
(test "accessors 8" #t (either-ref (left #t) values (constantly #f)))

(test "accessors 9" '(#t #f) (either-ref (right #t #f) (constantly #f) list))
(test "accessors 10" '(#t #f) (either-ref (left #t #f) list (constantly #f)))

(test "accessors 11" #t (maybe-ref/default (just #t) #f))
(test "accessors 12" #f (maybe-ref/default (nothing) #f))
(test "accessors 13" '(#t #t) (values->list (maybe-ref/default (just #t #t) #f #f)))
(test "accessors 14" '(#f #f) (values->list (maybe-ref/default (nothing) #f #f)))

(test "accessors 15" #t (either-ref/default (right #t) #f))
(test "accessors 16" #f (either-ref/default (left #t) #f))
(test "accessors 17" '(#t #t) (values->list (either-ref/default (right #t #t) #f #f)))
(test "accessors 18" '(#f #f) (values->list (either-ref/default (left #t) #f #f)))

;;;; Join and bind

  ;; maybe-join
(test "maybe-join 1" #t (just-of-z? (maybe-join (just (just 'z)))))
(test "maybe-join 2" #t (nothing? (maybe-join (just (nothing)))))
(test "maybe-join 3" #t (nothing? (maybe-join (nothing))))

  ;; either-join
(test "either-join 1" #t (right-of-z? (either-join (right (right 'z)))))
(test "either-join 2" #t (left-of-z? (either-join (right (left 'z)))))
(test "either-join 3" #t (left-of-z? (either-join (left 'z))))

;; maybe-bind
(test "maybe-bind 1" #t (nothing? (maybe-bind (nothing) just)))

(test "maybe-bind 2" #t (just-of-z? (maybe-bind (just 'z) just)))

(test "maybe-bind 3" #t (let ((m (just #t #f)))
           (maybe= eqv? m (maybe-bind m just))))


;; Associativity of bind.
(let ((k (lambda (n) (just (* n 2))))
      (h (lambda (n) (just (+ n 5))))
      (m (just 1)))
  (test "Associativity of bind" #t (maybe= eqv?
                      (maybe-bind m (lambda (n) (maybe-bind (k n) h)))
                      (maybe-bind (maybe-bind m k) h))))


;; Bind with multiple mprocs.
(let ((neg (lambda (b) (just (not b)))))
  (test "Bind with multiple mprocs 1" #t (maybe= eqv? (just #f) (maybe-bind (just #t) neg neg neg)))
  (test "Bind with multiple mprocs 2" #t (nothing? (maybe-bind (just #t) neg (constantly (nothing)) neg))))

;; maybe-compose
(test "maybe-compose 1" #t (nothing? ((maybe-compose (constantly (nothing))) 'z)))
(test "maybe-compose 2" #t (just-of-z? ((maybe-compose just) 'z)))

;; Compose with multiple mprocs.
(let ((neg (lambda (b) (just (not b)))))
  (test "Compose with multiple mprocs" #t (maybe= eqv? (just #t) ((maybe-compose neg neg neg) #f))))

;; either-bind
(test "either-bind 1" #t (left? (either-bind (left #f) right)))

(test "either-bind 2" #t (right-of-z? (either-bind (right 'z) right)))

(test "either-bind 3" #t (let ((e (right #t #f)))
              (either= eqv? e (either-bind e right))))

;; Associativity of bind.
(let ((k (lambda (n) (right (* n 2))))
      (h (lambda (n) (right (+ n 5))))
      (e (right 1)))
  (test "Associativity of bind 2" #t
     (either= eqv? (either-bind e (lambda (n) (either-bind (k n) h)))
                   (either-bind (either-bind e k) h))))

;; Bind with multiple mprocs.
(let ((neg (lambda (b) (right (not b)))))
  (test "Bind with multiple mprocs 3" #t (either= eqv? (right #f) (either-bind (right #t) neg neg neg)))
  (test "Bind with multiple mprocs 4" #t (either= eqv? (left #f) (either-bind (right #t) neg left neg))))

;; either-compose
(test "either-compose" #t (left-of-z? ((either-compose left) 'z)))
(test "either-compose 2" #t (either= eqv? (right #t) ((either-compose right) #t)))

;; Compose with multiple mprocs.
(let ((neg (lambda (b) (right (not b)))))
  (test "Compose with multiple mprocs" #t (either= eqv? (right #t) ((either-compose neg neg neg) #f))))


;;;; Sequence operations

(define (both b c) (and b c))

(test "maybe-length 0" 0 (maybe-length (nothing)))
(test "maybe-length 1" 1 (maybe-length (just #t)))

(test "either-length 0" 0 (either-length (left #t)))
(test "either-length 1" 1 (either-length (right #t)))

;; maybe-filter & maybe-remove
(test "maybe-filter & maybe-remove 1" #t (just-of-z? (maybe-filter always (just 'z))))
(test "maybe-filter & maybe-remove 2" #t (nothing? (maybe-filter never (just #t))))
(test "maybe-filter & maybe-remove 3" #t (nothing? (maybe-filter always (nothing))))

(test "maybe-filter & maybe-remove 4" #t (maybe= eqv? (just #t #t) (maybe-filter both (just #t #t))))

(test "maybe-filter & maybe-remove 5" #t (just-of-z? (maybe-remove never (just 'z))))
(test "maybe-filter & maybe-remove 6" #t (nothing? (maybe-remove always (just #t))))
(test "maybe-filter & maybe-remove 7" #t (nothing? (maybe-remove always (nothing))))

(test "maybe-filter & maybe-remove 8" #t (maybe= eqv? (just #t #f) (maybe-remove both (just #t #f))))

;; maybe-sequence
(test "maybe-sequence" #t
      (maybe= equal? (maybe-sequence (map just '(#t #f)) map identity)
              (just '(#t #f))))

(test "maybe-sequence 2" #t
      (maybe= equal? (maybe-sequence (list (just 1 #t) (just 2 #f))
                                     map
                                     list)
              (just '((1 #t) (2 #f)))))

(test "maybe-sequence 3" #t
      (nothing? (maybe-sequence (list (just #t) (nothing)) map identity)))

;; either-filter & either-remove
(test "either-filter & either-remove" #t (right-of-z? (either-filter always (right 'z) #f)))
(test "either-filter & either-remove 2" #t (left-of-z? (either-filter never (right #t) 'z)))
(test "either-filter & either-remove 3" #t (left-of-z? (either-filter always (left #t) 'z)))

(test "either-filter & either-remove 4" #t
      (either= eqv? (right #t #t) (either-filter both (right #t #t) #f)))

(test "either-filter & either-remove 5" #t (right-of-z? (either-remove never (right 'z) #f)))
(test "either-filter & either-remove 6" #t (left-of-z? (either-remove always (right #t) 'z)))
(test "either-filter & either-remove 7" #t (left-of-z? (either-remove never (left #t) 'z)))

(test "either-filter & either-remove 8"  #t
      (either= eqv? (right #t #f) (either-remove both (right #t #f) #f)))

;; either-sequence
(test "either-sequence 1" #t
      (either= equal? (either-sequence (map right (list 1 2)) map identity)
               (right (list 1 2))))
(test "either-sequence 2" #t
      (left-of-z? (either-sequence (list (right #t) (left 'z)) map identity)))
(test "either-sequence 3" #t
      (either= equal? (either-sequence (list (right 1 #t) (right 2 #f))
                                       map
                                       list)
               (right '((1 #t) (2 #f)))))


;;;; Protocol conversion procedures

(test "maybe->list (nothing)" '() (maybe->list (nothing)))
(test "conversion 2" '(#t #t) (maybe->list (just #t #t)))
(test "conversion 3" '(#t #t) (either->list (right #t #t)))
(test "conversion 4" '(#t #t) (either->list (left #t #t)))

(test "conversion 5" #t (nothing? (list->maybe '())))
(test "conversion 6" #t (just-of-z? (list->maybe '(z))))
(test "conversion 7" #t (left-of-z? (list->either '() 'z)))
(test "conversion 8" #t (right-of-z? (list->either '(z) #f)))

(test "conversion 9" #f (maybe->truth (nothing)))
(test "maybe->truth, just" 'z (maybe->truth (just 'z)))
(test "conversion 11" #f (either->truth (left 'z)))
(test "maybe->truth, right" 'z (either->truth (right 'z)))

(test "conversion 13" #t (nothing? (truth->maybe #f)))
(test "conversion 14" #t (just-of-z? (truth->maybe 'z)))
(test "conversion 15" #t (left-of-z? (truth->either #f 'z)))
(test "conversion 16" #t (right-of-z? (truth->either 'z #f)))

(test "conversion 17" '(z #t) (maybe->list-truth (just 'z #t)))
(test "conversion 18" #f (maybe->list-truth (nothing)))
(test "conversion 19" '(z #t) (either->list-truth (right 'z #t)))
(test "conversion 20" #f (either->list-truth (left 'z)))

(test "conversion 21" #t (just-of-z? (list-truth->maybe '(z))))
(test "conversion 22" #t (nothing? (list-truth->maybe #f)))
(test "conversion 23" #t (right-of-z? (list-truth->either '(z))))
(test "conversion 24" #t (left-of-z? (list-truth->either #f 'z)))

(test "conversion 25" #t (eof-object? (maybe->generation (nothing))))
(test "conversion 26" #t (maybe->generation (just #t)))
(test "conversion 27" #t (nothing? (generation->maybe (eof-object))))
(test "conversion 28" #t (just-of-z? (generation->maybe 'z)))

(test "conversion 29" #t (eof-object? (either->generation (left))))
(test "conversion 30" #t (either->generation (right #t)))
(test "conversion 31" #t (left-of-z? (generation->either (eof-object) 'z)))
(test "conversion 32" #t (right-of-z? (generation->either 'z #f)))

;; maybe->values and friends
(test "maybe->values and friends 1" #t (maybe->values (just #t)))
(test "maybe->values and friends 2" '() (values->list (maybe->values (nothing))))

(test "maybe->values and friends 3" '(#f #f) (values->list (maybe->two-values (nothing))))
(test "maybe->values and friends 4" '(#t #t) (values->list (maybe->two-values (just #t))))

(test "maybe->values and friends 5" #t (just-of-z? (two-values->maybe (lambda () (values 'z #t)))))
(test "maybe->values and friends 6" #t (nothing? (two-values->maybe (lambda () (values 'z #f)))))

(test "maybe->values and friends 7" #t (nothing? (values->maybe (lambda () (values)))))
(test "maybe->values and friends 8" #t (just-of-z? (values->maybe (lambda () 'z))))
(test "maybe->values and friends 9" #t (maybe->values (values->maybe (lambda () #t))))
(test "maybe->values and friends 10" #t (just-of-z? (values->maybe (lambda ()
                                         (maybe->values (just 'z))))))

;; either->values and friends
(test "either->values and friends 1" #t (either->values (right #t)))
(test "either->values and friends 2" '() (values->list (either->values (left 'z))))

(test "either->values and friends 3" #t (left-of-z? (values->either (lambda () (values)) 'z)))
(test "either->values and friends 4" #t (right-of-z? (values->either (lambda () 'z) #f)))
(test "either->values and friends 5" #t (either->values (values->either (lambda () #t) #f)))
(test "either->values and friends 6" #t (right-of-z? (values->either (lambda () (either->values (right 'z))) #f)))

(test "either->values and friends 7" #t (left-of-z? (exception->either symbol? (lambda () (raise 'z)))))
(test "either->values and friends 8" #t (right-of-z? (exception->either symbol? (lambda () 'z))))

(test "guarded" 'z (guard (obj ((symbol? obj) obj))
                     (exception->either number?
                                        (lambda () (raise-continuable 'z)))))

(test "exception->either" #t (either= eqv?
                                      (with-exception-handler
                                          not
                                        (lambda ()
                                          (exception->either string?
                                                             (lambda ()
                                                               (not (raise-continuable #t))))))
                                      (right #t)))


;;;; Map, fold, and unfold

  ;; maybe-map
(test "Map, fold, and unfold 1" #t (nothing? (maybe-map not (nothing))))
(test "Map, fold, and unfold 2" #t (maybe= eqv? (just #f) (maybe-map not (just #t))))

(test "Map, fold, and unfold 3" #t (maybe= eqv? (just #t #f) (maybe-map values (just #t #f))))

;; either-map
  ;; Verify that the result is the same Left (in the sense of eqv?).
(test "Map, fold, and unfold 4" #t (let ((e (left #t))) (eqv? e (either-map not e))))
(test "Map, fold, and unfold 5" #t (either= eqv? (right #f) (either-map not (right #t))))

(test "Map, fold, and unfold 6" #t (let ((e (right #t #f)))
              (either= eqv? e (either-map values e))))

;; maybe-for-each
(test "maybe-for-each 1" #t (let ((x #f))
              (maybe-for-each (lambda (y) (set! x y)) (just #t))
              x))

;; Given Nothing, ensure the proc argument is not executed.
(test "maybe-for-each 2" #f
      (let ((x #f))
        (maybe-for-each (lambda (_) (set! x #t)) (nothing))
        x))

;; either-for-each
(test "either-for-each" #t (let ((x #f))
              (either-for-each (lambda (y) (set! x y)) (right #t))
              x))

;; Given a Left, ensure the proc argument is not executed.
(test "Map, fold, and unfold 10" #f (let ((x #f))
              (either-for-each (lambda (_) (set! x #t)) (left 'z))
              x))

(test "Map, fold, and unfold 11" '() (maybe-fold cons '() (nothing)))
(test "Map, fold, and unfold 12" '(#t) (maybe-fold cons '() (just #t)))
(test "Map, fold, and unfold 13" 24 (maybe-fold * 2 (just 3 4)))

(test "Map, fold, and unfold 14" '() (either-fold cons '() (left #t)))
(test "Map, fold, and unfold 15" '(#t) (either-fold cons '() (right #t)))
(test "Map, fold, and unfold 16" 24 (either-fold * 2 (right 3 4)))

(test "Map, fold, and unfold 17" #t (nothing? (maybe-unfold always not always #f)))
(test "Map, fold, and unfold 18" #t (maybe= eqv? (just #t) (maybe-unfold values not not #f)))
(test "Map, fold, and unfold 19" #t (maybe= eqv? (just #t 'z)
                         (maybe-unfold (lambda (b _) (not b))
                                       values
                                       (lambda (b x) (values (not b) x))
                                       #t
                                       'z)))

(test "Map, fold, and unfold 20" #t (left-of-z? (either-unfold always not always 'z)))
(test "Map, fold, and unfold 21" #t (either= eqv? (right #t) (either-unfold values not not #f)))
(test "Map, fold, and unfold 22" #t (either= eqv? (right #t 'z)
                       (either-unfold (lambda (b _) (not b))
                                      values
                                      (lambda (b x) (values (not b) x))
                                      #t
                                      'z)))





;;;; Trivalent logic

(define (tri-true? m)
  (and (just? m) (maybe-ref/default m 'z)))

(define (tri-false? m)
  (and (just? m) (not (maybe-ref/default m 'z))))

(test "trivalent 1" #t (tri-true? (tri-not (just #f))))
(test "trivalent 2" #t (tri-false? (tri-not (just #t))))
(test "trivalent 3" #t (nothing? (tri-not (nothing))))

(test "trivalent 4" #t (tri-true? (tri=? (just #t) (just 1) (just 'x))))
(test "trivalent 5" #t (tri-true? (tri=? (just #f) (just #f))))
(test "trivalent 6" #t (tri-true? (tri=? (just #f) (just #f))))
(test "trivalent 7" #t (tri-false? (tri=? (just #f) (just #t))))
(test "trivalent 8" #t (tri-false? (tri=? (just #f) (nothing))))

(test "trivalent 9" #t (tri-true? (tri-and (just #t) (just 1) (just 'x))))
(test "trivalent 10" #t (nothing? (tri-and (just #t) (nothing))))
(test "trivalent 11" #t (tri-false? (tri-and (just #f) (just #t))))
(test "trivalent 12" #t (tri-true? (tri-and)))

(test "trivalent 13" #t (tri-false? (tri-or (just #f) (just #f) (just #f))))
(test "trivalent 14" #t (nothing? (tri-or (just #f) (nothing))))
(let ((m-true (just 'x)))
  (test "trivalent 15" #t (maybe= eqv? m-true (tri-or (just #f) m-true))))
(test "trivalent 16" #t (tri-false? (tri-or)))

(test "trivalent 17" #t (nothing? (tri-merge (nothing) (nothing) (nothing))))
(let ((m-true (just 'x)))
  (test "trivalent 18" #t (maybe= eqv? m-true (tri-merge (nothing) m-true))))
(let ((m-false (just #f)))
  (test "trivalent 19" #t (maybe= eqv? m-false (tri-merge (nothing) m-false))))
(test "trivalent 20" #t (nothing? (tri-merge)))

;; ----------------------------------------------------------------------
;;  SRFI 190 ...
;; ----------------------------------------------------------------------
(test-subsection "SRFI 190 - Coroutine Generators")

(require "srfi-190")

(let ()
  (define g1 (coroutine-generator
           (do ((i 0 (+ i 1)))
               ((<= 5 i))
             (yield i))))

  (define g2 (let ((yield-square (lambda (yield i) (yield (* i i)))))
               (coroutine-generator
                (do ((i 0 (+ i 1)))
                    ((<= 5 i))
                  (yield-square yield i)))))

  (define-coroutine-generator (g3 n)
    (do ((i 0 (+ i 1)))
        ((<= n i))
      (yield i)))

  (test "Coroutine generator.1" '(0 1 2 3 4)
        (generator->list g1))
  (test "Coroutine generator.2" '(0 1 4 9 16)
        (generator->list g2))
  (test "Coroutine generator.3" '(0 1 2 3 4 5 6)
        (generator->list (g3 7))))

;; ----------------------------------------------------------------------
;;  SRFI 193 ...
;; ----------------------------------------------------------------------
(test-subsection "SRFI-193 - Command Line")

(let ((val (command-line)))
  (test "command-line validate" #t
        (and (list? val)
               (not (null? val))
               (or (boolean? (car val))
                   (string? (car val)))
               (every string? (cdr val))))
  (test "command-args"
        #t
        (eq? (cdr val)
             (command-args))))

(parameterize ((command-line '("" "1" "2")))
  (test "new command line.1"
        #t
        (let ((val (command-line)))
          (and (not (command-name))
               (equal? '("1" "2")
                       (command-args))))))

(parameterize ((command-line '("../../foo.stk" "1" "2" "3")))
  (test "new command line.2 (suffix must be supressed)"
        #t
        (let ((val (command-line)))
          (and (string=? (command-name) "foo")
               (equal? '("1" "2" "3")
                       (command-args))))))

(parameterize ((command-line '("../../foo.keep" "1" "2" "3")))
  (test "new command line.3 (suddix must be kept)"
        #t
        (let ((val (command-line)))
          (and (string=? (command-name) "foo.keep")
               (equal? '("1" "2" "3")
                       (command-args))))))

;; ----------------------------------------------------------------------
;;  SRFI 195 ...
;; ----------------------------------------------------------------------
;; Tests are in the file test-box.stk

;; ----------------------------------------------------------------------
;;  SRFI 196 ...
;; ----------------------------------------------------------------------
(test-subsection "SRFI-196 - Range objects")

(require "srfi-196")

(define *tests-failed* 0)

(define-syntax check
  (syntax-rules (=>)
    ((check expr => expected)
     (test "" expected expr))))

(define (identity x) x)

;; change print-header to make tests silent
;; -- jpellegrini
(define (print-header message) (void))
  ;; (newline)
  ;; (display ";;; ")
  ;; (display message)
  ;; (newline))

(define-syntax constantly
  (syntax-rules ()
    ((_ obj) (lambda _ obj))))

(define always (constantly #t))
(define never (constantly #f))

(define (range=/eqv? ra rb)
  (range=? eqv? ra rb))

(define (%range-empty? r) (zero? (range-length r)))

;;;; Test ranges

(define test-num-range (numeric-range 10 30))

(define test-num-seq (iota 20 10))

(define test-empty-range (numeric-range 0 0))

;; Produces the range {#f, #t}.
(define test-bool-range
  (range 2 (lambda (n) (not (zero? n)))))

;;;; Conversion

(define (check-conversion)
  (print-header "Running conversion tests...")

  (check (range->list test-empty-range) => '())
  (check (range->list test-bool-range)  => '(#f #t))
  (check (range->list test-num-range)   => test-num-seq)

  (check (generator->list (range->generator test-num-range))
   => test-num-seq)

  (check (vector->list (range->vector test-num-range)) => test-num-seq)

  (check (range->string test-empty-range) => "")
  (let ((s "0123456789"))
    (check (range->string (string-range s)) => s))

  (let* ((vec (vector 1 3 5 7 9))
         (vrange (vector->range vec)))
    (check (range-length vrange)  => (vector-length vec))
    (check (range-first vrange)   => (vector-ref vec 0))
    (check (range-last vrange)    => (vector-ref vec 4))
    (check (range->vector vrange) => vec)
    (check (range->list (begin (vector-set! vec 0 0) vrange))
     => '(1 3 5 7 9)))
)

(define (check-constructors)
  (print-header "Running constructor tests...")

  (check (%range-empty? (numeric-range 1 1))      => #t)
  (check (range->list (numeric-range -5 -1))      => (iota 4 -5))
  (check (range->list (numeric-range 1 -5 -1))    => (iota 6 1 -1))
  (check (range->list (numeric-range 4/3 16/3))   => (iota 4 4/3))
  (check (range->list (numeric-range 0 9 4))      => (iota 3 0 4))
  (check (%range-empty? (numeric-range 0 10 -1))  => #t)
  (check (%range-empty? (numeric-range 0 -10))    => #t)
  (check (range->list (numeric-range 5 1 -1))     => (iota 4 5 -1))
  (check (range->list (numeric-range -2 2))       => (iota 4 -2))
  (check (range->list (numeric-range 2 -2 -1))    => (iota 4 2 -1))
  (check (range->list (numeric-range -4 -8 -1))   => (iota 4 -4 -1))
  (check (range->list (numeric-range -1 -4 -2/3)) => (iota 5 -1 -2/3))

  (check (range=/eqv? (iota-range 10 0 0)
                      (range 10 (lambda (_) 0)))
   => #t)
  (check (%range-empty? (iota-range 0))     => #t)
  (check (range->list (iota-range 10))      => (iota 10))
  (check (range->list (iota-range 10 0))    => (iota 10))
  (check (range->list (iota-range 10 0 1))  => (iota 10))
  (check (range->list (iota-range 10 10 2)) => (iota 10 10 2))
  (check (range->list (iota-range 10 0 -1)) => (iota 10 0 -1))
  (check (range->list (iota-range 10 5 -2)) => (iota 10 5 -2))
  (check (range->list (iota-range 10 1/2))  => (iota 10 1/2))

  (let ((vec (vector 1 3 5 7 9)))
    (check (range-length (vector-range vec))  => (vector-length vec))
    (check (range-first (vector-range vec))   => (vector-ref vec 0))
    (check (range-last (vector-range vec))    => (vector-ref vec 4))
    (check (range->vector (vector-range vec)) => vec))

  (let* ((s "0123456789") (srange (string-range s)))
    (check (range-length srange) => (string-length s))
    (check (range-first srange)  => (string-ref s 0))
    (check (range-last srange)   => (string-ref s 9))
    (check (range->list srange)  => (string->list s)))
)

;;;; Predicates

(define (check-predicates)
  (print-header "Running predicate tests...")

  (check (range=? eqv? (numeric-range 0 0) (numeric-range 5 5))  => #t)
  (check (range=? eqv? (numeric-range 0 0) test-num-range)       => #f)
  (check (range=? eqv? test-num-range test-num-range)            => #t)
  (check (range=? eqv? test-num-range (numeric-range 10 30))     => #t)
  (check (range=? eqv? test-num-range (numeric-range 10 20))     => #f)
  (check (range=? eqv? test-bool-range (vector-range #(#f #t))) => #t)
  (check (range=? eqv? test-bool-range (vector-range #(#t #f))) => #f)
  (check (range=? eqv?
                  test-num-range
                  (numeric-range 10 30)
                  (subrange (numeric-range 0 50) 10 30))
   => #t)
  (check (range=? eqv?
                  test-bool-range
                  (numeric-range 10 30)
                  (subrange (numeric-range 0 50) 10 30))
   => #f)
  (check (range=? eqv?
                  test-num-range
                  (numeric-range 11 31)
                  (subrange (numeric-range 0 50) 10 30))
   => #f)
)

;;;; Accessors

(define (check-accessors)
  (print-header "Running accessor tests...")

  (check (range-ref test-num-range 0)  => 10)
  (check (range-ref test-bool-range 1) => #t)
)

;;;; Iteration

(define (check-iteration)
  (print-header "Running iteration tests...")

  ;; Check lengths of ranges returned by range-split-at.
  (let ((n 10))
    (check (let-values (((ra rb) (range-split-at test-num-range n)))
             (list (range-length ra) (range-length rb)))
     => (list n (- (range-length test-num-range) n))))

  ;; Joining the two ranges returned by range-split-at gives the
  ;; original range.
  (check (let-values (((ra rb) (range-split-at test-bool-range 1)))
           (range=/eqv? (range-append ra rb) test-bool-range))
   => #t)

  (check (range=/eqv?
          (subrange test-bool-range 0 (range-length test-bool-range))
          test-bool-range)
   => #t)
  (let ((a 5) (b 10))
    (check (= (range-length (subrange test-num-range a b)) (- b a))
     => #t)
    (check (range=/eqv? (subrange test-num-range a b)
                        (range-take (range-drop test-num-range a) (- b a)))
     => #t)
    (check (range=/eqv? (subrange test-num-range 0 b)
                        (range-take test-num-range b))
     => #t)
    (check (range=/eqv?
            (subrange test-num-range a (range-length test-num-range))
            (range-drop test-num-range a))
     => #t))

  ;; range-take r n returns a range of length n.
  (check (range-length (range-take test-num-range 10)) => 10)
  (check (range-length
          (range-take test-num-range (range-length test-num-range)))
   => (range-length test-num-range))
  (check (range->list (range-take test-num-range 5))
   => (take test-num-seq 5))

  ;; range-take-right r n returns a range of length n.
  (check (range-length (range-take-right test-num-range 10)) => 10)
  (check (range-length
          (range-take-right test-num-range (range-length test-num-range)))
   => (range-length test-num-range))
  (check (range->list (range-take-right test-num-range 5))
   => (drop test-num-seq 15))

  ;; range-drop r n returns a range of length (range-length r) - n.
  (check (range-length (range-drop test-num-range 10))
   => (- (range-length test-num-range) 10))
  (check (range-length
          (range-drop test-num-range (range-length test-num-range)))
   => 0)
  (check (range->list (range-drop test-num-range 15))
   => (drop test-num-seq 15))

  ;; range-drop-right r n returns a range of length (range-length r) - n.
  (check (range-length (range-drop-right test-num-range 10))
   => (- (range-length test-num-range) 10))
  (check (range-length
          (range-drop-right test-num-range (range-length test-num-range)))
   => 0)
  (check (range->list (range-drop-right test-num-range 15))
   => (take test-num-seq 5))

  (check (range=/eqv? (car (range-segment test-num-range 5))
                      (range-take test-num-range 5))
   => #t)
  (check (range=/eqv? (apply range-append
                             (cdr (range-segment test-num-range 5)))
                      (range-drop test-num-range 5))
   => #t)
  (check (range=/eqv? (apply range-append (range-segment test-num-range 5))
                      test-num-range)
   => #t)
  (check (fold + 0 (map range-length (range-segment test-num-range 5)))
   => (range-length test-num-range))
  (check (fold + 0 (map range-length (range-segment test-num-range 7)))
   => (range-length test-num-range))

  (check (range-count always test-num-range) => (range-length test-num-range))
  (check (range-count never test-num-range)  => 0)
  (check (range-count even? test-num-range)  => (count even? test-num-seq))
  (check (range-count (lambda (x y) y) test-num-range test-bool-range)
   => 1)
  (check (range-count (lambda (x y) (zero? (+ x y)))
                      test-num-range
                      (range-map - test-num-range))
   => (range-length test-num-range))

  (check (range-any even? test-num-range) => #t)
  (check (range-any never test-num-range) => #f)
  (check (range-any (lambda (x y) y) test-num-range test-bool-range)
   => #t)
  (check (range-any (lambda (x y) (zero? (+ x y)))
                    test-num-range
                    test-num-range)
   => #f)

  (check (range-every number? test-num-range) => #t)
  (check (range-every even? test-num-range)   => #f)
  (check (range-every (lambda (x y) y) test-num-range test-bool-range)
   => #f)
  (check (range-every (lambda (x y) (zero? (+ x y)))
                      test-num-range
                      (range-map - test-num-range))
   => #t)

  ;;; map, filter-map, & for-each

  (check (range=/eqv? (range-map (lambda (x) (+ 1 x)) test-num-range)
                      (numeric-range 11 31))
   => #t)
  (check (equal? (range->list (range-map square test-num-range))
                 (map square test-num-seq))
   => #t)
  (check (range=/eqv? (range-map + test-num-range test-num-range)
                      (numeric-range 20 60 2))
   => #t)
  ;; range-map over ranges with unequal lengths terminates when
  ;; the shortest range is exhausted.
  (check (range=/eqv?
          (range-map (lambda (x _) x) test-num-range test-bool-range)
          (range-take test-num-range (range-length test-bool-range)))
   => #t)

  ;; (range-map->list f r) = (map f (range->list r))
  (check (equal? (range-map->list not test-bool-range)
                 (map not (range->list test-bool-range)))
   => #t)
  (check (equal? (range-map->list + test-num-range test-num-range)
                 (map + test-num-seq test-num-seq))
   => #t)

  ;; (range-map->vector f r) = (map f (range->vector r))
  (check (equal? (range-map->vector not test-bool-range)
                 (vector-map not (range->vector test-bool-range)))
   => #t)
  (let ((num-vec (list->vector test-num-seq)))
    (check (equal? (range-map->vector + test-num-range test-num-range)
                   (vector-map + num-vec num-vec))
     => #t))

  (check (%range-empty? (range-filter-map never test-bool-range)) => #t)
  (check (range=/eqv? (range-filter-map values test-num-range)
                      test-num-range)
   => #t)
  (check (equal?
          (range->list (range-filter-map (lambda (x) (and (even? x) x))
                                         test-num-range))
          (filter-map (lambda (x) (and (even? x) x)) test-num-seq))
   => #t)
  (let ((proc (lambda (x y) (and (even? x) (even? y) (+ x y)))))
    (check (range=/eqv? (range-filter-map proc test-num-range test-num-range)
                        (numeric-range 20 60 4))
     => #t))

  (check (range-filter-map->list never test-bool-range) => '())
  (check (equal? (range-filter-map->list values test-num-range)
                 test-num-seq)
   => #t)
  (check (equal?
          (range-filter-map->list (lambda (x) (and (even? x) x))
                                  test-num-range)
          (filter-map (lambda (x) (and (even? x) x)) test-num-seq))
   => #t)
  (let ((proc (lambda (x y) (and (even? x) (even? y) (+ x y)))))
    (check (equal? (range-filter-map->list proc
                                           test-num-range
                                           test-num-range)
                   (filter-map proc test-num-seq test-num-seq))
     => #t))

  (check (let ((v #f))
           (range-for-each (lambda (x) (set! v x)) test-bool-range)
           v)
   => #t)
  (check (let ((v #f))
           (range-for-each (lambda (x y) (when y (set! v x)))
                           test-num-range
                           test-bool-range)
           v)
   => 11)

  ;;; filter & remove

  (check (range=/eqv? (range-filter always test-bool-range)
                      test-bool-range)
   => #t)
  (check (%range-empty? (range-filter never test-bool-range)) => #t)
  (check (equal? (range->list (range-filter even? test-num-range))
                 (filter even? test-num-seq))
   => #t)

  (check (range-filter->list always test-bool-range) => '(#f #t))

  (check (null? (range-filter->list never test-bool-range)) => #t)

  ;; (range-filter->list pred r) = (filter pred (range->list r))
  (check (equal? (range-filter->list even? test-num-range)
                 (filter even? test-num-seq))
   => #t)

  (check (range=/eqv? (range-remove never test-bool-range)
                      test-bool-range)
   => #t)
  (check (%range-empty? (range-remove always test-bool-range))
   => #t)
  (check (equal? (range->list (range-remove even? test-num-range))
                 (remove even? test-num-seq))
   => #t)

  (check (equal? (range-remove->list never test-bool-range)
                 (range->list test-bool-range))
   => #t)

  (check (null? (range-remove->list always test-bool-range)) => #t)

  ;; (range-remove->list pred r) = (remove pred (range->list r))
  (check (equal? (range-remove->list even? test-num-range)
                 (remove even? test-num-seq))
   => #t)

  ;; (range-fold (lambda (b) (+ 1 b)) 0 r) = (range-length r)
  (check (= (range-fold (lambda (b _) (+ b 1)) 0 test-num-range)
            (range-length test-num-range))
   => #t)

  ;; (range-fold proc nil r) = (fold proc nil (range->list r))
  (check (equal? (range-fold + 0 test-num-range)
                 (fold + 0 test-num-seq))
   => #t)

  (check (= (range-fold + 0 test-num-range test-num-range)
            (fold + 0 test-num-seq test-num-seq))
   => #t)

  ;; range-fold over ranges with unequal lengths terminates when
  ;; the shortest range is exhausted.
  (check (= (range-fold (lambda (s x _) (+ s x))
                        0
                        test-num-range
                        test-bool-range)
            (range-fold + 0 (range-take test-num-range
                                        (range-length test-bool-range))))
   => #t)

  ;; (range-fold-right (lambda (b) (+ 1 b)) 0 r) = (range-length r)
  (check (= (range-fold-right (lambda (b _) (+ b 1)) 0 test-num-range)
            (range-length test-num-range))
   => #t)

  ;; (range-fold-right r proc nil) = (fold-right proc nil (range->list r))
  (check (equal? (range-fold-right + 0 test-num-range)
                 (fold-right + 0 test-num-seq))
   => #t)

  (check (= (range-fold-right + 0 test-num-range test-num-range)
            (fold-right + 0 test-num-seq test-num-seq))
   => #t)

  ;; range-fold-right over ranges with unequal lengths terminates when
  ;; the shortest range is exhausted.
  (check (= (range-fold-right (lambda (s x _) (+ s x))
                              0
                              test-num-range
                              test-bool-range)
            (range-fold-right + 0 (range-take test-num-range
                                              (range-length
                                               test-bool-range))))
   => #t)

  (check (eqv? (range-first (range-reverse test-bool-range))
               (range-last test-bool-range))
   => #t)

  (check (eqv? (range-last (range-reverse test-bool-range))
               (range-first test-bool-range))
   => #t)

  (check (equal? (range->list (range-reverse test-num-range))
                 (reverse test-num-seq))
   => #t)

  (check (%range-empty? (range-append)) => #t)
  (check (range->list (range-append test-bool-range)) => '(#f #t))
  (check (range=/eqv? (range-append (numeric-range 10 20)
                                    (numeric-range 20 30))
                      test-num-range)
   => #t)
  (check (range=/eqv? (range-append (numeric-range 10 15)
                                    (numeric-range 15 20)
                                    (numeric-range 20 25)
                                    (numeric-range 25 30))
                      test-num-range)
   => #t)
)

;;;; Searching

(define (check-searching)
  (print-header "Running search tests...")

  (check (range-index always test-num-range) => 0)
  (check (range-index never test-num-range)  => #f)
  (check (range-index values test-bool-range) => 1)
  (check (range-index (lambda (x y) (and (odd? x) y))
                      test-num-range
                      test-bool-range)
   => 1)

  (check (eqv? (range-index-right always test-num-range)
               (- (range-length test-num-range) 1))
   => #t)
  (check (range-index-right never test-num-range)  => #f)
  (check (range-index-right values test-bool-range) => 1)
  (check (range-index-right (lambda (x y) (< (+ x y) 30))
                            test-num-range
                            test-num-range)
   => 4)

  ;; range-index and range-index-right produce the same index if pred
  ;; is only satisfied by the element at that index.
  (let ((fifteen? (lambda (n) (= n 15))))
    (check (= (range-index fifteen? test-num-range)
              (range-index-right fifteen? test-num-range)
              (list-index fifteen? test-num-seq))
     => #t))

  ;; (range-take-while always r) = r
  (check (range=/eqv? (range-take-while always test-bool-range)
                      test-bool-range)
   => #t)

  ;; (range-take-while never r) = [empty range]
  (check (%range-empty? (range-take-while never test-bool-range)) => #t)

  (let ((pred (lambda (n) (< n 15))))
    (check (range->list (range-take-while pred test-num-range))
     => (take-while pred test-num-seq)))

  ;; (range-drop-while always r) = [empty range]
  (check (%range-empty? (range-drop-while always test-bool-range)) => #t)

  ;; (range-drop-while never r) = r
  (check (range=/eqv? (range-drop-while never test-bool-range)
                      test-bool-range)
   => #t)

  (let ((pred (lambda (n) (< n 15))))
    (check (range->list (range-drop-while pred test-num-range))
     => (drop-while pred test-num-seq)))

  ;; (range-append (range-take-while p r) (range-drop-while p r)) = r
  (let ((pred (lambda (n) (< n 10))))
    (check (range=/eqv?
            (range-append (range-take-while pred test-num-range)
                          (range-drop-while pred test-num-range))
            test-num-range)
     => #t))

  ;; (range-take-while-right always r) = r
  (check (range=/eqv? (range-take-while-right always test-bool-range)
                      test-bool-range)
   => #t)

  ;; (range-take-while-right never r) = [empty range]
  (check (%range-empty? (range-take-while-right never test-bool-range)) => #t)

  (let ((pred (lambda (n) (>= n 15))))
    (check (range->list (range-take-while-right pred test-num-range))
     => (iota 15 15)))

  ;; (range-drop-while-right always r) = [empty range]
  (check (%range-empty? (range-drop-while-right always test-bool-range)) => #t)

  ;; (range-drop-while-right never r) = r
  (check (range=/eqv? (range-drop-while-right never test-bool-range)
                      test-bool-range)
   => #t)

  (let ((pred (lambda (n) (>= n 15))))
    (check (range->list (range-drop-while-right pred test-num-range))
     => (take test-num-seq 5)))

  ;; (range-append (range-drop-while-right p r)
  ;;               (range-take-while-right p r)) = r
  (let ((pred (lambda (n) (< n 10))))
    (check (range=/eqv?
            (range-append (range-drop-while-right pred test-num-range)
                          (range-take-while-right pred test-num-range))
            test-num-range)
     => #t))
)

(define (check-all)
  (check-predicates)
  (check-conversion)
  (check-constructors)
  (check-accessors)
  (check-iteration)
  (check-searching)

  ;;(newline)
  ;;(check-report)
  )

(check-all)


;; ----------------------------------------------------------------------
(test-section-end)
