;;;;
;;;; readline-complete.stk   -- tab completion for readline
;;;;
;;;; Copyright © 2022 Jeronimo Pellegrini <j_p@aleph0.info>
;;;;
;;;;
;;;; This program is free software; you can redistribute it and/or modify
;;;; it under the terms of the GNU General Public License as published by
;;;; the Free Software Foundation; either version 2 of the License, or
;;;; (at your option) any later version.
;;;;
;;;; This program is distributed in the hope that it will be useful,
;;;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;;;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;;;; GNU General Public License for more details.
;;;;
;;;; You should have received a copy of the GNU General Public License
;;;; along with this program; if not, write to the Free Software
;;;; Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
;;;; USA.
;;;;           Author: Jerônimo Pellegrini [j_p@aleph0.info]
;;;;    Creation date: 08-May-2022 08:59
;;;; Last file update: 24-May-2022 12:43 (eg)

(select-module stklos/readline-complete)



(define (get-module-symbols module)
  ;; Find all the global symbols of a module/library
  (append (module-symbols (current-module))
          (if (library? module)
              '()
              (module-symbols (find-module 'STklos)))))



;;
;; A default completer function, which completes on the symbols usable
;; at the global level of the current REPL module
;;
(define (default-complete-function str)
  (if (zero? (string-length str))
      '()
      (let ((symbols (get-module-symbols (current-module))))
        ;; We just compare the prefix. Perhapes in the future we could optionally
        ;; use a regexp so the user can decide to match any parts of the word (like,
        ;; type 'polar', hit tab, and get the expansion 'make-polar')
        ;; If we do that, we need to be careful to properly escape the matching string.
        (let ((size (string-length str)))
          (let ((match (lambda (s)
                         (and (>= (string-length s) size)
                              (string=? str (substring s 0 size))))))
            (filter match (map symbol->string symbols)))))))

;;
;; The parameter completer-function contains the function used to complete strings
;; It defaults to default-complet-function
;;
(define completer-function (make-parameter default-complete-function))


;; readline-completion-generator is a generator of string completions.
;; It takes as argument a string, 'str' and a state indicator, 'state'.
;;
;; - Completions will be searched for 'str'.
;; - When state is #f a fresh list of completions is searched, and the first
;; item is returned.
;; - When state is #t the next of the current list is returned.
;;
;; This is written this way to match the expected behavior of the readline
;; function rl_completion_matches.
(define readline-completion-generator
  (let ((ans '()))
    (lambda (str state)
      (when (not state)
        (set! ans ((completer-function) str)))
      (if (null? ans)
          ans
          (let ((s (car ans)))
            (set! ans (cdr ans))
            s)))))

;;
;; Initialization
;;
(unless (eq? (key-get *%system-state-plist* :readline 'no-readline)
             'no-readline)
  ;; Tell readline to start doing tab completion, by passing our completion
  ;; function to it.
  (%init-readline-completion-function readline-completion-generator))

(provide "stklos/readline-complete")
