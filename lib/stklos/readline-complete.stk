;;;;
;;;; readline-complete.stk   -- tab completion for readline
;;;;
;;;; Copyright © 2022 Jeronimo Pellegrini <j_p@aleph0.info>
;;;;
;;;;
;;;; This program is free software; you can redistribute it and/or modify
;;;; it under the terms of the GNU General Public License as published by
;;;; the Free Software Foundation; either version 2 of the License, or
;;;; (at your option) any later version.
;;;;
;;;; This program is distributed in the hope that it will be useful,
;;;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;;;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;;;; GNU General Public License for more details.
;;;;
;;;; You should have received a copy of the GNU General Public License
;;;; along with this program; if not, write to the Free Software
;;;; Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
;;;; USA.
;;;;           Author: Jerônimo Pellegrini [j_p@aleph0.info]
;;;;    Creation date: 08-May-2022 08:59
;;;; Last file update: 11-May-2022 07:50 (jpellegrini)

(select-module stklos/readline-complete)

(export readline-completion-generator
        readline-complete-get-modules
        init-readline-completion-function)

#|
<doc EXT readline-complete-get-modules
 * (readline-complete-get-modules)
 *
 * This is a parameter that holds one procedure. The procedure should
 * return a list that specifies the modules that will be searched when
 * doing tab completion, and which symbols should be considered from
 * each module.
 * The list returned from the procedure is a list of conses, where
 * the CAR is a module, and the CDR is :export when only the exported
 * symbols should be considered from that module.
 *
 * The default value is
 * @lisp
 * (lambda () (list (cons (find-module 'STklos) :export)
 *             (cons (current-module)      :all)))
 * @end lisp
 * which will read all exported symbols in the STklos module and all
 * symbols (exported or not) from the current module.
doc>
|#
(define readline-complete-get-modules
  (make-parameter
   (lambda () (list (cons (find-module 'STklos) :export)
               (cons (current-module)      :all)))))

;; Returns a list with the symbols in 'module'.
;; If 'inly-exports' is equal to #:export, only exported
;; symbols are considered.
(define (get-module-symbols module only-exports)
  (map symbol->string
       (if (eq? only-exports #:export)
           (map car (module-exports module))
           (module-symbols (current-module)))))

;; Given a string 'str' (which is the partially typed string in the
;; REPL), the 'complete' procedure uses the 'readline-complete-get-modules'
;; parameter to get all completions for that string.
(define (complete str)
  ;; We need to bail out when the length is zero, otherwise the program crashes.
  (if (zero? (string-length str))
      '()
      (let* ((modules ((readline-complete-get-modules)))
             (symbols-lists (map (lambda (mod+ext)
                                   (get-module-symbols (car mod+ext) (cdr mod+ext)))
                                 modules))
             (symbols (apply append symbols-lists)))
        
        ;; We just compare the prefix. Perhapes in the future we could optionally
        ;; use a regexp so the user can decide to match any parts of the word (like,
        ;; type 'polar', hit tab, and get the expansion 'make-polar')
        ;; If we do that, we need to be careful to properly escape the matching string.
        (let ((size (string-length str)))
          (let ((match (lambda (s)
                         (and (>= (string-length s) size)
                          (string=? str (substring s 0 size))))))
            ;;(write (format #f "str [~a] res ~a~%" str (filter match symbols)) (current-error-port))
            (filter match symbols))))))

;; readline-completion-generator is a generator of string completions.
;; It takes as argument a string, 'str' and a state indicator, 'state'.
;; 
;; - Completions will be searched for 'str'.
;; - When state is #f a fresh list of completions is searched, and the first
;; item is returned.
;; - When state is #t the next of the current list is returned.
;; 
;; This is written this way to match the expected behavior of the readline
;; function rl_completion_matches.
(define readline-completion-generator #f)

(let ((ans '()))
  (set! readline-completion-generator
    (lambda (str state)
      (when (not state) (set! ans (complete str)))
      (if (null? ans)
          ans
          (let ((s (car ans)))
            (set! ans (cdr ans))
            s)))))

;; init-readline-completion-function actually tells readline to start
;; doing tab completion, and passes our completion function to it.
(define (init-readline-completion-function)
  (unless (eq? (key-get *%system-state-plist* :readline 'no-readline)
               'readline)
    (error "readline completion requested, but readline not installed")
  (%init-readline-completion-function readline-completion-generator))

(provide "stklos/readline-complete")
