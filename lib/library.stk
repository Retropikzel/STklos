;;;;
;;;;
;;;; library.stk         -- R7RS define-library
;;;;
;;;; Copyright © 2019-2022 Erick Gallesio <eg@unice.fr>
;;;;
;;;;
;;;; This program is free software; you can redistribute it and/or modify
;;;; it under the terms of the GNU General Public License as published by
;;;; the Free Software Foundation; either version 2 of the License, or
;;;; (at your option) any later version.
;;;;
;;;; This program is distributed in the hope that it will be useful,
;;;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;;;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;;;; GNU General Public License for more details.
;;;;
;;;; You should have received a copy of the GNU General Public License
;;;; along with this program; if not, write to the Free Software
;;;; Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
;;;; USA.
;;;;
;;;;           Author: Erick Gallesio [eg@unice.fr]
;;;;    Creation date: 18-Oct-2019 14:08
;;;; Last file update:  8-Apr-2022 12:44 (eg)
;;;;

;;
;; Define common standard libraries to minimize files accesses at runtime
;;
(include "./scheme/base.stk")
(include "./scheme/write.stk")

;;
;; library name conversion functions
;;
(define (%library-name->string libname)
  (define (->string libname)
    (let* ((str (format #f "~A" libname))
           (res (substring str 1 (- (string-length str) 1))))
      (regexp-replace-all " " res "/")))

  (cond
   ((symbol? libname)                                   ;; STklos
    (symbol->string libname))
   ((and (pair? libname)
         (list? libname)
         (every (lambda (x)
                  (or (symbol? x) (and (integer? x)
                                       (positive? x))))
                libname)
         (->string libname)))
   (else
    (error "bad library name ~S" libname))))


(define (%library-name->symbol libname)
  (string->symbol (%library-name->string libname)))

(define (%symbol->library-name name)
  (map string->symbol (string-split (symbol->string name) "/")))

;;
;; A macro to redefine a symbol in a R7RS module
;;
(define-macro (%module-define-and-export . lst)
  `(begin
     ,@(map (lambda (x) `(%symbol-define ',x ,x)) lst)
     (export ,@lst)))


;; ======================================================================
;;
;; DEFINE-LIBRARY
;;
;; ======================================================================
(define (%eventually-create-library name)
  (or (find-module name #f)
      (let ((lib (%make-library)))
        (%register-library-as-module lib name)
        lib)))

(define-macro (define-library name . decls)
  (let* ((module-name    (%library-name->symbol name))
         (imports        '())
         (exports        '())
         (body           '())
         (lib            (gensym))
         (module-restore (symbol-value '%module-restore
                                       (find-module 'STklos))))

    ;; Parse declarations
    (for-each (lambda (d)
                (unless (pair? d)
                  (error 'define-library "bad library declaration clause ~s" d))
                (let ((key  (car d))
                      (rest (cdr d)))
                  (case key
                    ((import)
                     (let ((imp (%parse-imports rest)))
                       (set! imports (append! imports (list imp)))))
                    ((export)
                     (let ((exp (%parse-exports rest)))
                       (set! exports (append! exports (list exp)))))
                    ((begin include include-ci)
                     (set! body (append body (list d))))
                    (else
                     (error 'define-library "incorrect directive ~s" d)))))
              decls)
    ;;
    ;; Produce the expansion
    ;;
    ;; The difficulty here is that libraries have an empty environment. That
    ;; means that we cannot expand in a "define-module" and do the imports
    ;; and the exports in it. Consequently, we work in two time:
    ;;  1. First, we create an empty library and fill it with the import and
    ;;     the export. This is done in in the STklos environment
    ;;  2. Then, we use a standard define-module which will use the library
    ;;     previously built where the imports/exports have bee forged.
    ;;
    `(begin
       ;; ①: Define (eventually) the library and do the imports and exports
       (let ((,lib (%eventually-create-library ',module-name)))
         ;; Do the imports
         ,@(map (lambda (x) `(%do-imports ,lib ',x #f)) imports)

         ;; Do the exports
         ,@(map (lambda (x) `(%do-exports ,lib ',x)) exports)

         ;; HACK: %module-restore is used at the end of the expansion.
         ;; We define here it locally to permit the module restoration
         (%symbol-define '%module-restore %module-restore ,lib))

       ;; ②: Define a standard STklos module
       (define-module ,module-name ,@body))))


#|
<doc EXT library-name
 * (library-name lib)
 *
 * Returns the name of |lib| if it was defined as an R7RS library,
 * and #f if the library is anonymous. If |lib| is not a library, 
 * |library-name| raises an error.
 *
 * @lisp
 * (define-library (example cool-library))
 * (library-name (find-module 'example/cool-library)) => (example cool-library)
 * (module-name  (find-module 'example/cool-library)) => example/cool-library
 *
 * (define-module example/a-module)
 * (library-name (find-module 'example/a-module))     => error
 *
 * (library-name quotient)                            => error
 * @end lisp
doc>
|#
(define (library-name lib)
  (unless (library? lib)
    (if (module? lib)
        (error 'library-name "module ~S is not a library" (module-name lib))
        (error 'library-name "bad module/library ~S" lib)))
  (let ((name (module-name lib)))
    (and (not (eq? name #void))
         (%symbol->library-name (module-name lib)))))
