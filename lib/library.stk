;;;;
;;;;
;;;; library.stk         -- R7RS define-library
;;;;
;;;; Copyright Â© 2019-2021 Erick Gallesio <eg@unice.fr>
;;;;
;;;;
;;;; This program is free software; you can redistribute it and/or modify
;;;; it under the terms of the GNU General Public License as published by
;;;; the Free Software Foundation; either version 2 of the License, or
;;;; (at your option) any later version.
;;;;
;;;; This program is distributed in the hope that it will be useful,
;;;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;;;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;;;; GNU General Public License for more details.
;;;;
;;;; You should have received a copy of the GNU General Public License
;;;; along with this program; if not, write to the Free Software
;;;; Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
;;;; USA.
;;;;
;;;;           Author: Erick Gallesio [eg@unice.fr]
;;;;    Creation date: 18-Oct-2019 14:08
;;;; Last file update: 14-Oct-2021 16:01 (eg)
;;;;

;;
;; Define common standard libraries to minimize files accesses at runtime
;;
(include "./scheme/base.stk")
(include "./scheme/write.stk")

;;
;; library name conversion functions
;;
(define (%library-name->string libname)
  (define (->string libname)
    (let* ((str (format #f "~A" libname))
           (res (substring str 1 (- (string-length str) 1))))
      (regexp-replace-all " " res "/")))

  (cond
   ((symbol? libname)                                   ;; STklos
    (symbol->string libname))
   ((and (pair? libname)
         (list? libname)
         (every (lambda (x)
                  (or (symbol? x) (and (integer? x)
                                       (positive? x))))
                libname)
         (->string libname)))
   (else
    (error "bad library name ~S" libname))))


(define (%library-name->symbol libname)
  (string->symbol (%library-name->string libname)))

(define (%symbol->library-name name)
  (map string->symbol (string-split (symbol->string name) "/")))

;;
;; A macro to redefine a symbol in a R7RS module
;;
(define-macro (%module-define-and-export . lst)
  `(begin
     ,@(map (lambda (x) `(%symbol-define ',x ,x)) lst)
     (export ,@lst)))


;; ======================================================================
;;
;; IMPORT
;;
;; ======================================================================
(define (%do-imports lib clauses)

  (define (parse-import import-set)
    ;; Build a key-list of the import-set. If the import-set is
    ;;       (prefix (only (a b) x y z) foo-),
    ;; it returns a list of the form
    ;;       (a/b #:only (x y z) #:prefix foo-)
    (cond
     ((list? import-set)
      (let ((key (car import-set)))
        (case key

          ((only except)
           (if (>= (length import-set) 3)
               (let ((identifiers (cddr import-set)))
                 ;; Verify that all the identfiers are symbols
                 (unless (every symbol? identifiers)
                   (error 'import "bad list of symbols ~s in ~a clause"
                          identifiers key))
                 `(,@(parse-import (cadr import-set))
                   ,(string->keyword (symbol->string key))
                   ,identifiers))
               (error 'inport "bad only clause ~s" import-set)))

          ((prefix)
           (if (and (= (length import-set) 3)
                    (symbol? (caddr import-set)))
               `(,@(parse-import (cadr import-set))
                 #:prefix
                 ,(caddr import-set))
               (error 'inport "bad prefix clause ~s" import-set)))

          ((rename)
           (if (>= (length import-set) 3)
               (let ((assocs (cddr import-set)))
                 ;; Verify that all the assocs are well formed
                 (unless (every (lambda (x)
                                  (and (list? x) (= (length x) 2)
                                       (symbol? (car x)) (symbol? (cadr x))))
                                assocs)
                   (error 'import "bad list of associations ~s in rename clause"
                          assocs))
                 `(,@(parse-import (cadr import-set))
                   #:rename
                   ,assocs))
               (error 'inport "bad rename clause ~s" import-set)))

          (else
           (list (%library-name->symbol import-set))))))

     ((symbol? import-set)
      ;; a "legacy" STklos module
      (list import-set))

     (else
      (error 'import "bad import set ~s" import-set))))

  (define (eventually-load-library name)
    (let ((module (find-module name #f)))
      (cond
        (module)
        (else
         ;; Try to load a file which could define this module
         (require/provide (symbol->string name))

         ;; Verify that the was correctly defined in this file
         (let ((mod (find-module name #f)))
           (unless mod
             (error 'import "module/library ~s does not exist"
                    (%symbol->library-name name)))
           mod)))))

  (define (import-symbols importer name only except rename prefix)
    (let* ((mod       (eventually-load-library name))
           (exported  (map (lambda(x)
                             ;; FIXME: pair if lib atom if module
                             (if (pair? x) x (cons x x)))
                           (module-exports mod))))

      (when except
        ;; Suppress the symbols in the except list
        (let ((public (map cdr exported)))
          (for-each (lambda (symb)
                      (if (memq symb public)
                          (set! exported (remove (lambda(x) (eq? (cdr x) symb)) exported))
                          (error 'import "except: symbol ~s is not in the import set"
                                 symb)))
                    except)))

      (when only
        ;; Verify that all the symbols in the only list are exported
        (let ((public (map cdr exported)))
          (for-each (lambda (x)
                      (unless (memq x public)
                        (error 'import "only: symbol ~s is not in the import set"
                               x)))
                    only))
        ;; Restrict now the exported set to the only list
        (set! exported (filter! (lambda (x) (memq (cdr x) only))
                                exported)))

      (when rename
        ;; Rename some symbols
        (for-each (lambda (couple)
                    (let ((original (car couple))
                          (new      (cadr couple)))
                      (let Loop ((lst exported))
                        (if (null? lst)
                            (error 'import "rename: symbol ~s is not in the import set"
                                   original)
                            (if (eq? (cdar lst) original)
                                (set-cdr! (car lst) new)
                                (Loop (cdr lst)))))))
                  rename))

        (when prefix
          ;; Prefix symbols
          (for-each (lambda (pair)
                      (set-cdr! pair (symbol-append prefix (cdr pair))))
                    exported))


        ;; Now we can (finally) make aliases for all symbols in exported list
        ;; FIXME: cannot be compiled ==> make a runtime call for that
        ;; something like (%module-link (module-name mod) exported)
        (for-each (lambda (pair)
                    (%symbol-link (cdr pair) (car pair) lib mod))
                  exported)))

  ;; Call import-symbols for each import spec
  (for-each (lambda (imp)
              (let* ((flat    (parse-import imp))
                     (name     (car flat))
                     (keylist  (cdr flat)))
                (import-symbols lib
                                name
                                (key-get keylist #:only   #f)
                                (key-get keylist #:except #f)
                                (key-get keylist #:rename #f)
                                (key-get keylist #:prefix #f))))
            clauses))


;; ======================================================================
;;
;; EXPORT
;;
;; ======================================================================

(define (module-exports-alist lst)
  (map (lambda (x)
         (if (symbol? x)
             (cons x x)
             (cons (cadr x) (caddr x))))
       lst))

(define (%do-exports lib symbols)

;;  (define (parse-exports exports)
;;    (for-each (lambda (x)
;;                (unless (or (symbol? x)
;;                            (and (list? x)
;;                                 (= (length x) 3)
;;                                 (eq? (car x)'rename)
;;                                 (symbol? (cadr x))
;;                                 (symbol? (caddr x))))
;;                  (error 'export "bad export" x)))
;;              exports))
;;
  ;;
  ;; %do-exports
  ;;
  ;; (parse-exports symbols)

  (define (add-symbol name rename lst)
    (let ((old (assq name lst)))
      (if old
          (let ((old-rename (cdr old)))
            (unless (or (eq? name old-rename)
                        (eq? old-rename rename))
              (error 'export "exported symbol ~s was previously renamed as ~S"
                     name old-rename))
            (set-cdr! old rename)
            lst)
          (cons (cons name rename) lst))))

  (let Loop ((l symbols) (res (module-exports lib)))
    (if (null? l)
        (begin
          ;; Hack to avoid useless compilation messages.
          (for-each register-new-global!  (map car res))

          ;; Add the symbols to the export list
          (%module-exports-set! lib res))

        (cond
         ((symbol? (car l))
          ;;
          ;; export a single identifier
          ;;
          (let ((s (car l)))
            (Loop (cdr l)
                  (add-symbol s s res))))

         ((and (pair? (car l))
               (eq? (caar l) 'rename))
          ;;
          ;; export with renaming: (rename old new)
          ;;
          (let ((symbs (cdar l)))
            (unless (and (= (length symbs) 2)
                         (symbol? (car symbs))
                         (symbol? (cadr symbs)))
              (error 'export "bad renaming clause ~S" (car l)))
            (Loop (cdr l)
                  (add-symbol (car symbs) (cadr symbs) res))))

         (else
          (error 'export "bad exportation `~S'" (car l)))))))


;; ======================================================================
;;
;; DEFINE-LIBRARY
;;
;; ======================================================================
(define-macro (define-library name . decls)
  (let* ((module-name    (%library-name->symbol name))
         (lib            (or (find-module module-name #f) (%make-library)))
         (body           '())
         (module-restore (symbol-value '%module-restore
                                       (find-module 'STklos))))

    ;; Parse declarations
    (for-each
     (lambda (d)
       (unless (pair? d)
         (error 'define-library "bad library declaration clause ~s" d))
       (let ((key  (car d))
             (rest (cdr d)))
         (case key
           ((import)
                (%do-imports lib rest))
           ((export)
                (%do-exports lib rest))
           ((begin include include-ci)
                (set! body (append body (list d))))
           (else
                (error 'define-library "incorrect directive ~s" d)))))
     decls)

    ;; register the created lib in the global module list
    (%register-library-as-module lib module-name)

    ;; Build the result that must be evaluated
    `(define-module ,module-name
       ;; FIXME: %module-restore is used at the end of the expansion.
       ;; We define here it locally to permit the module restoration
       (define %module-restore ,module-restore)
       ,@body)))
