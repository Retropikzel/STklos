;;;;
;;;;
;;;; library.stk         -- R7RS define-library
;;;;
;;;; Copyright © 2019-2021 Erick Gallesio <eg@unice.fr>
;;;;
;;;;
;;;; This program is free software; you can redistribute it and/or modify
;;;; it under the terms of the GNU General Public License as published by
;;;; the Free Software Foundation; either version 2 of the License, or
;;;; (at your option) any later version.
;;;;
;;;; This program is distributed in the hope that it will be useful,
;;;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;;;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;;;; GNU General Public License for more details.
;;;;
;;;; You should have received a copy of the GNU General Public License
;;;; along with this program; if not, write to the Free Software
;;;; Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
;;;; USA.
;;;;
;;;;           Author: Erick Gallesio [eg@unice.fr]
;;;;    Creation date: 18-Oct-2019 14:08
;;;; Last file update: 22-Oct-2021 15:17 (eg)
;;;;

;;
;; Define common standard libraries to minimize files accesses at runtime
;;
(include "./scheme/base.stk")
(include "./scheme/write.stk")

;;
;; library name conversion functions
;;
(define (%library-name->string libname)
  (define (->string libname)
    (let* ((str (format #f "~A" libname))
           (res (substring str 1 (- (string-length str) 1))))
      (regexp-replace-all " " res "/")))

  (cond
   ((symbol? libname)                                   ;; STklos
    (symbol->string libname))
   ((and (pair? libname)
         (list? libname)
         (every (lambda (x)
                  (or (symbol? x) (and (integer? x)
                                       (positive? x))))
                libname)
         (->string libname)))
   (else
    (error "bad library name ~S" libname))))


(define (%library-name->symbol libname)
  (string->symbol (%library-name->string libname)))

(define (%symbol->library-name name)
  (map string->symbol (string-split (symbol->string name) "/")))

;;
;; A macro to redefine a symbol in a R7RS module
;;
(define-macro (%module-define-and-export . lst)
  `(begin
     ,@(map (lambda (x) `(%symbol-define ',x ,x)) lst)
     (export ,@lst)))


;; ======================================================================
;;
;; IMPORT
;;
;; ======================================================================
(define (%do-imports lib clauses)

  (define (parse-import import-set)
    ;; Build a key-list of the import-set. If the import-set is
    ;;       (prefix (only (a b) x y z) foo-),
    ;; it returns a list of the form
    ;;       (a/b #:only (x y z) #:prefix foo-)
    (cond
     ((list? import-set)
      (let ((key (car import-set)))
        (case key

          ((only except)
           (if (>= (length import-set) 3)
               (let ((identifiers (cddr import-set)))
                 ;; Verify that all the identfiers are symbols
                 (unless (every symbol? identifiers)
                   (error 'import "bad list of symbols ~s in ~a clause"
                          identifiers key))
                 `(,@(parse-import (cadr import-set))
                   ,(string->keyword (symbol->string key))
                   ,identifiers))
               (error 'inport "bad only clause ~s" import-set)))

          ((prefix)
           (if (and (= (length import-set) 3)
                    (symbol? (caddr import-set)))
               `(,@(parse-import (cadr import-set))
                 #:prefix
                 ,(caddr import-set))
               (error 'inport "bad prefix clause ~s" import-set)))

          ((rename)
           (if (>= (length import-set) 3)
               (let ((assocs (cddr import-set)))
                 ;; Verify that all the assocs are well formed
                 (unless (every (lambda (x)
                                  (and (list? x) (= (length x) 2)
                                       (symbol? (car x)) (symbol? (cadr x))))
                                assocs)
                   (error 'import "bad list of associations ~s in rename clause"
                          assocs))
                 `(,@(parse-import (cadr import-set))
                   #:rename
                   ,assocs))
               (error 'inport "bad rename clause ~s" import-set)))

          (else
           (list (%library-name->symbol import-set))))))

     ((symbol? import-set)
      ;; a "legacy" STklos module
      (list import-set))

     (else
      (error 'import "bad import set ~s" import-set))))

  (define (eventually-load-library name)
    (let ((module (find-module name #f)))
      (cond
        (module)
        (else
         ;; Try to load a file which could define this module
         (require/provide (symbol->string name))

         ;; Verify that the was correctly defined in this file
         (let ((mod (find-module name #f)))
           (unless mod
             (error 'import "module/library ~s does not exist"
                    (%symbol->library-name name)))
           mod)))))

  (define (import-symbols importer name only except rename prefix)
    (let* ((mod       (eventually-load-library name))
           (exported  (map (lambda(x)
                             ;; FIXME: pair if lib atom if module
                             (if (pair? x) x (cons x x)))
                           (module-exports mod))))

      (when except
        ;; Suppress the symbols in the except list
        (let ((public (map cdr exported)))
          (for-each (lambda (symb)
                      (if (memq symb public)
                          (set! exported (remove (lambda(x) (eq? (cdr x) symb)) exported))
                          (error 'import "except: symbol ~s is not in the import set"
                                 symb)))
                    except)))

      (when only
        ;; Verify that all the symbols in the only list are exported
        (let ((public (map cdr exported)))
          (for-each (lambda (x)
                      (unless (memq x public)
                        (error 'import "only: symbol ~s is not in the import set"
                               x)))
                    only))
        ;; Restrict now the exported set to the only list
        (set! exported (filter! (lambda (x) (memq (cdr x) only))
                                exported)))

      (when rename
        ;; Rename some symbols
        (for-each (lambda (couple)
                    (let ((original (car couple))
                          (new      (cadr couple)))
                      (let Loop ((lst exported))
                        (if (null? lst)
                            (error 'import
                                   "rename: symbol ~s is not in the import set"
                                   original)
                            (if (eq? (cdar lst) original)
                                (set-cdr! (car lst) new)
                                (Loop (cdr lst)))))))
                  rename))

        (when prefix
          ;; Prefix symbols
          (for-each (lambda (pair)
                      (set-cdr! pair (symbol-append prefix (cdr pair))))
                    exported))


        ;; Now we can (finally) make aliases for all symbols in exported list
        ;; FIXME: cannot be compiled ==> make a runtime call for that
        ;; something like (%module-link (module-name mod) exported)
        (for-each (lambda (pair)
                    (%symbol-link (cdr pair) (car pair) lib mod))
                  exported)))

  ;; Call import-symbols for each import spec
  (for-each (lambda (imp)
              (let* ((flat    (parse-import imp))
                     (name     (car flat))
                     (keylist  (cdr flat)))
                (import-symbols lib
                                name
                                (key-get keylist #:only   #f)
                                (key-get keylist #:except #f)
                                (key-get keylist #:rename #f)
                                (key-get keylist #:prefix #f))))
            clauses))


;; ======================================================================
;;
;; DEFINE-LIBRARY
;;
;; ======================================================================
(define (%eventually-create-library name)
  (or (find-module name #f)
      (let ((lib (%make-library)))
        (%register-library-as-module lib name)
        lib)))

(define-macro (define-library name . decls)
  (let* ((module-name    (%library-name->symbol name))
         (imports        '())
         (exports        '())
         (body           '())
         (lib            (gensym))
         (module-restore (symbol-value '%module-restore
                                       (find-module 'STklos))))

    ;; Parse declarations
    (for-each
     (lambda (d)
       (unless (pair? d)
         (error 'define-library "bad library declaration clause ~s" d))
       (let ((key  (car d))
             (rest (cdr d)))
         (case key
           ((import)
                (set! imports (append! imports (list rest))))
           ((export)
                (let ((exp (%parse-exports rest)))
                  (set! exports (append! exports (list exp)))))
           ((begin include include-ci)
                (set! body (append body (list d))))
           (else
                (error 'define-library "incorrect directive ~s" d)))))
     decls)
    ;;
    ;; Produce the expansion
    ;;
    ;; The difficulty here is that libraries have an empty environment. That
    ;; means that we cannot expand in a "define-module" and do the imports
    ;; and the exports in it. Consequently, we work in two time:
    ;;  1. First, we create an empty library and fill it with the import and
    ;;     the export. This is done in in the STklos environment
    ;;  2. Then, we use a standard define-module which will use the library
    ;;     previously built where the imports/exports have bee forged.
    ;;
    `(begin
       ;; ①: Define (eventually) the library and do the imports and exports
       (let ((,lib (%eventually-create-library ',module-name)))
         ;; Do the imports
         ,@(map (lambda (x) `(%do-imports ,lib ',x)) imports)

         ;; Do the exports
         ,@(map (lambda (x) `(%do-exports ,lib ',x)) exports)

         ;; HACK: %module-restore is used at the end of the expansion.
         ;; We define here it locally to permit the module restoration
         (%symbol-define '%module-restore %module-restore ,lib))

       ;; ②: Define a standard STklos module
       (define-module ,module-name ,@body))))
